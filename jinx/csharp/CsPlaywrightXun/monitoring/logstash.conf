# Logstash configuration for Enterprise Automation Framework
input {
  # Docker logs
  beats {
    port => 5044
  }
  
  # File logs
  file {
    path => "/app/logs/*.log"
    start_position => "beginning"
    codec => "json"
    tags => ["automation-framework", "application"]
  }
  
  # Test result logs
  file {
    path => "/app/reports/*.trx"
    start_position => "beginning"
    codec => "xml"
    tags => ["automation-framework", "test-results"]
  }
  
  # Syslog
  syslog {
    port => 514
    tags => ["syslog"]
  }
}

filter {
  # Parse automation framework logs
  if "automation-framework" in [tags] {
    if [message] =~ /^\{/ {
      json {
        source => "message"
      }
    }
    
    # Extract test information
    if [TestName] {
      mutate {
        add_field => { "test_name" => "%{TestName}" }
        add_field => { "test_category" => "%{Category}" }
        add_field => { "test_status" => "%{Status}" }
      }
    }
    
    # Parse timestamps
    date {
      match => [ "Timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
    }
    
    # Add environment information
    mutate {
      add_field => { "environment" => "${ENVIRONMENT:development}" }
      add_field => { "service" => "automation-framework" }
    }
  }
  
  # Parse test results
  if "test-results" in [tags] {
    xml {
      source => "message"
      target => "test_result"
    }
    
    # Extract test metrics
    if [test_result][TestRun][Results][UnitTestResult] {
      ruby {
        code => "
          results = event.get('[test_result][TestRun][Results][UnitTestResult]')
          if results.is_a?(Array)
            passed = results.count { |r| r['outcome'] == 'Passed' }
            failed = results.count { |r| r['outcome'] == 'Failed' }
            skipped = results.count { |r| r['outcome'] == 'NotExecuted' }
          else
            passed = results['outcome'] == 'Passed' ? 1 : 0
            failed = results['outcome'] == 'Failed' ? 1 : 0
            skipped = results['outcome'] == 'NotExecuted' ? 1 : 0
          end
          
          event.set('test_metrics', {
            'passed' => passed,
            'failed' => failed,
            'skipped' => skipped,
            'total' => passed + failed + skipped
          })
        "
      }
    }
  }
  
  # Parse error logs
  if [level] == "Error" or [level] == "Fatal" {
    mutate {
      add_tag => ["error"]
    }
    
    # Extract stack trace
    if [exception] {
      mutate {
        add_field => { "error_type" => "%{[exception][Type]}" }
        add_field => { "error_message" => "%{[exception][Message]}" }
        add_field => { "stack_trace" => "%{[exception][StackTrace]}" }
      }
    }
  }
  
  # Grok patterns for common log formats
  grok {
    match => { 
      "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{GREEDYDATA:log_message}" 
    }
    tag_on_failure => ["_grokparsefailure"]
  }
  
  # Remove sensitive information
  mutate {
    remove_field => ["password", "token", "secret", "key"]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "automation-framework-%{+YYYY.MM.dd}"
    template_name => "automation-framework"
    template => "/usr/share/logstash/templates/automation-framework.json"
    template_overwrite => true
  }
  
  # Debug output (remove in production)
  if [environment] == "development" {
    stdout {
      codec => rubydebug
    }
  }
  
  # Send alerts to external systems
  if "error" in [tags] {
    http {
      url => "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
      http_method => "post"
      format => "json"
      mapping => {
        "text" => "Error in Automation Framework: %{error_message}"
        "channel" => "#alerts"
        "username" => "LogstashBot"
      }
    }
  }
}